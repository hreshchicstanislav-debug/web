# Обзор вкладки «Задачи»

Документ описывает бизнес-логику вкладки `#/tasks`, цепочку синхронизации «Asana → Supabase → PWA» и пути к коду, который нужно править при изменениях.

## 1. Назначение вкладки
- Вкладка `#/tasks` (маршрут обрабатывается в `app.js/route()`) показывает недельный прогресс по задачам Asana: сколько товаров уже отснято, сколько осталось и насколько команда близка к динамическому недельному плану (80–100 товаров в зависимости от недельной нагрузки).
- Экран служит единым окном для оперативного контроля: менеджеры не заходят в Asana, а видят актуальные цифры и детальные записи прямо в Timetrack PWA.

## 2. UI и основные экраны
- Статический заголовок «Задачи Asana».
- Сетка `#tasksGrid` с четырьмя карточками: «Отснято на неделе» (`#completedCount`), «Предстоит отснять` (`#pendingCount`), «Запланировано» (`#totalPlan`), «До выполнения плана» (`#cardRemaining` + `#remainingCount`).
- Кнопка `#refreshStats` («Обновить данные») — запускает ручную синхронизацию.
- Кнопка `#showDetails` («Показать подробности») разворачивает `#tasksDetailsContainer`, где выводится таблица задач недели (название, количество товаров, дата выполнения).
- На мобильных и сверхмалых экранах стили `#tasksGrid` переопределяются в `index.html`, чтобы карточки оставались читаемыми.

## 3. Поток данных при ручном обновлении

### 3.1. Пользовательский сценарий
1. Пользователь нажимает `#refreshStats` (см. `app.js/renderTasks()` строки ~1992–2154).
2. Обработчик отключает кнопку, показывает статус «Обновление…» и вызывает `supabaseClient.functions.invoke('fetch-asana-stats', { body: {} })`.
3. После успешного ответа происходит обновление карточек (`updateTasksCards(result.data)`), пересчет кеша `cachedTasksStats`, запуск фоновой загрузки деталей `getAsanaTasksDetailsByWeekStart(week_start_date)` и показ уведомления пользователю.

### 3.2. Edge Function `fetch-asana-stats`
1. Реализована в `supabase/functions/fetch-asana-stats/index.ts` (см. полный листинг в `ASANA_INTEGRATION.md`, §3.4).
2. Использует `fetch` к Asana REST API: `GET https://app.asana.com/api/1.0/tasks?workspace=1208507351529750&project=1210258013776969&assignee=me&limit=100&opt_fields=gid,name,completed,completed_at,due_on,assignee,created_at,modified_at,custom_fields`.
   - Параметры запроса: `workspace` (Arbuz workspace), `project` (Arbuz Контент. Задачи), `assignee=me` (задачи текущего пользователя).
3. Авторизация через Personal Access Token (`ASANA_PAT`), заголовок `Authorization: Bearer ...`.
4. **Защитная фильтрация по исполнителю**: перед записью в `asana_tasks` Edge Function отбрасывает задачи без `assignee` и задачи, где `task.assignee.gid !== TIMETRACK_ASSIGNEE_GID` (если переменная окружения установлена). Логируется количество задач до и после фильтрации.
4. Edge Function перебирает задачи и извлекает данные:
   - **Поле Q** (кастомное поле с числовым значением) — единственный источник количества товаров в задаче. Старое поле "Кол-во товаров" (GID `1210420107320602`) больше не используется в расчётах, хранится только как legacy.
   - **Поле "Товар"** (кастомное поле с enum-значениями) — определяет, лежит ли товар уже у фотографа ("Принесли") или его нужно взять со склада ("Взять самому со склада").
   - **Поле "когда сфоткал"** (кастомное поле с датой) — проставляется фотографом вручную, указывает дату съёмки.
   - **Поле "когда обработал"** (кастомное поле с датой) — проставляется фотографом вручную, указывает дату обработки. Если поле пустое, но задача завершена (`completed = true`), используется `completed_at` как дата обработки. **Важно:** Завершённая задача всегда попадает в "Сделано", даже если дата обработки не проставлена вручную — в этом случае используется дата завершения задачи.
5. Ключевые определения KPI (финальная логика v3):
   > **Важно:** Все KPI рассчитываются только по личным задачам фотографа (assignee = owner) из проекта "Arbuz Контент. Задачи", прошедшим фильтрацию на уровне Edge Function. Задачи других исполнителей или из других проектов не участвуют в расчётах.
   
   - **done_fact_this_week** — фактический объём, выполненный в отчётной неделе. Для каждой задачи с `Q > 0` и `completed = true` выбирается первая доступная неделя из `week_processed`, `week_shot` или `week_completed` (по `completed_at`). Если выбранная неделя совпадает с текущей, задача входит в `done_fact_this_week`.
   - **carry_over_from_prev** — объём переработки, который пришёл из прошлой недели (разница между `done_fact` и планом той недели). Он добавляется к `done_fact_this_week`, чтобы пользователь видел суммарное значение в карточке «Сделано».
   - **done_qty** — итоговое значение карточки «Сделано»: `done_fact_this_week + carry_over_from_prev`.
   - **to_shoot_qty** — сумма `Q` задач с `completed != true`, у которых `due_on` попадает в текущую неделю. Это плановый объём «предстоит».
   - **week_load** — недельная нагрузка: `done_fact_this_week + to_shoot_qty`. Она комбинирует фактически сделанное и плановые остатки этой недели.
   - **plan** — динамический план в диапазоне 80–100. Сравнивается именно с `done_fact_this_week`.
   - **remaining_to_plan** — `max(0, plan - done_fact_this_week)`.
   - **on_hand_qty** — сумма `Q` задач в текущей неделе по `due_on`, где `product_source = 'PRINESLI'`, задача не завершена, и `shot_at IS NULL` (товар ещё не сфотографирован, поэтому физически находится на руках).
   - **warehouse_qty** — сумма `Q` задач недели по `due_on`, где `product_source = 'WAREHOUSE'`, задача не завершена и работа ещё не начата (`shot_at IS NULL`, `processed_at IS NULL`).
   - **shot_not_processed_qty** — сумма `Q` задач, у которых `shot_at` заполнено, `processed_at` пусто, задача не завершена. Неделя определяется по `week_shot`.
   - **q_errors_count** — количество задач недели по `due_on` или `week_shot`, где `Q <= 0` или `Q IS NULL`, но задача должна участвовать в планах (есть дедлайн текущей недели или факт съёмки в этой неделе).
6. Использование дат:
   - `due_on` и `week_start_date` применяются для всех плановых показателей: `to_shoot_qty`, `on_hand_qty`, `warehouse_qty`, расчёта «ещё предстоит».
   - `shot_at`, `processed_at`, `completed_at` (а также `week_shot`, `week_processed`) применяются для фактических показателей: `done_fact_this_week`, распределение переработки, `shot_not_processed_qty`.
7. План и переработка:
   - `plan` рассчитывается по `week_load` (см. формулу ниже) и сравнивается только с `done_fact_this_week`.
   - `overtime_qty = max(0, done_fact_this_week - plan)` фиксируется в контексте текущей недели; следующая неделя использует это значение как `carry_over_from_prev`.
   - Карточка «Сделано» показывает `done_qty = done_fact_this_week + carry_over_from_prev`, чтобы менеджеры видели полный объём, зачтённый за неделю с учётом переносов.

### 3.3. Запись в Supabase
1. Edge Function создает сервисный клиент `createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)`.
2. Для текущей недели (`week_start_date`, `week_end_date`) ищет запись в таблице `asana_stats`. Если есть — `update`, иначе `insert`. Колонки: `completed_count` (KPI "Сделано" с учётом переработки), `pending_count`, `total_plan` (динамический план 80–100), `remaining_to_plan`, `updated_at`.
3. Детальные задачи записываются в `asana_tasks` (только задачи, прошедшие фильтрацию по проекту и исполнителю):
   - В таблицу попадают только задачи текущего пользователя из проекта "Arbuz Контент. Задачи", прошедшие защитную фильтрацию по `assignee_gid`.
   - Для каждой отфильтрованной задачи формируется объект с `asana_task_gid`, `task_name`, `completed`, `completed_at`, `due_on` (опорная плановая дата, связывает задачу с неделей по дедлайну), `assignee_gid`, а также новые поля:
     - `q` — количество товаров из поля Q (основной источник)
     - `product_source` — значение поля "Товар" ("Принесли" или "Взять самому со склада")
     - `shot_at` — дата из поля "когда сфоткал"
     - `processed_at` — дата из поля "когда обработал" (или `completed_at`, если поле пустое, но задача завершена)
     - `week_shot` — понедельник недели съёмки (на основе `shot_at`)
     - `week_processed` — понедельник недели обработки (на основе `processed_at`)
    - `week_start_date` — понедельник недели по `due_on`. Используется как ключ недели для всех плановых KPI, а также остаётся совместимой связкой с фронтендом.
   - Обновление делается upsert-операцией по `asana_task_gid`, чтобы одна и та же Asana-задача обновлялась, а не дублировалась.
4. Успешный ответ Edge Function возвращает JSON `{ success: true, data: statsData }`, который фронтенд тут же использует для обновления UI.

### 3.4. Автоматические обновления
- Edge Function `handle-asana-webhook` (см. `ASANA_INTEGRATION.md`, §4.1) принимает webhooks от Asana и синхронно вызывает `supabase.functions.invoke('fetch-asana-stats')`.
- SQL-функция `refresh_asana_stats()` + `pg_cron` (`refresh-asana-stats-frequent`) — резервный механизм для pull-сценария каждые 5 минут.
- Периодическая очистка `asana_stats` (`clear-asana-stats-weekly`) и `clean_asana_tasks.sql` гарантирую, что UI всегда работает с последней неделей.

## 4. Модель данных «Asana → Supabase»

| Сущность Asana | Описание | Куда пишется в Supabase |
| --- | --- | --- |
| `task.gid` | Уникальный идентификатор задачи | `asana_tasks.asana_task_gid` (PRIMARY/UNIQUE) |
| `task.name` | Название задачи (обычно «SKU + описание») | `asana_tasks.task_name` |
| `task.completed` | Булево «Завершена» | `asana_tasks.completed` |
| `task.completed_at` | Дата завершения | `asana_tasks.completed_at` (TIMESTAMPTZ) |
| `task.due_on` | Дедлайн задачи, определяет плановую неделю (используется для KPI to_shoot/on_hand/warehouse) | `asana_tasks.due_on` (DATE) |
| `task.assignee.gid` | Исполнитель (в нашем случае 1210252517070407) | `asana_tasks.assignee_gid` |
| **`task.custom_fields[].number_value` (поле Q)** | **Количество товаров в задаче (единственный источник)** | **`asana_tasks.q`** |
| `task.custom_fields[].number_value` (GID `1210420107320602`) | Старое поле "Кол-во товаров" — больше не используется в расчётах, хранится только как legacy | `asana_tasks.quantity` (legacy) |
| **`task.custom_fields[].enum_value` (поле "Товар")** | **Источник товара: "Принесли" или "Взять самому со склада"** | **`asana_tasks.product_source`** |
| **`task.custom_fields[].date_value` (поле "когда сфоткал")** | **Дата съёмки, проставляется фотографом вручную** | **`asana_tasks.shot_at`** |
| **`task.custom_fields[].date_value` (поле "когда обработал")** | **Дата обработки, проставляется фотографом вручную. Если пустое, но `completed = true`, используется `completed_at`** | **`asana_tasks.processed_at`** |
| Вычисление Monday по `shot_at` | Понедельник недели съёмки (используется для расчёта KPI) | `asana_tasks.week_shot` |
| Вычисление Monday по `processed_at` | Понедельник недели обработки (используется для расчёта KPI) | `asana_tasks.week_processed` |
| Вычисление Monday по `due_on` | Понедельник недели по плановой дате. Ключ для плановых KPI и выборок UI | `asana_tasks.week_start_date` |
| агрегированные суммы KPI "Сделано" (с учётом переработки), `pendingCount` | Итоговые показатели недели | `asana_stats.completed_count`, `asana_stats.pending_count` |
| `totalPlan` (динамический 80–100), `remainingToPlan`, `week_start_date`, `week_end_date` | Подсчитанные итоги недели | `asana_stats.total_plan`, `asana_stats.remaining_to_plan`, `asana_stats.week_start_date`, `asana_stats.week_end_date` |

> **Важно:** Поле Q является единственным источником количества товаров в задаче. Старое поле "Кол-во товаров" (GID `1210420107320602`) больше не используется в расчётах и хранится только как legacy для обратной совместимости.

> `week_start_date` вычисляется одинаково и для агрегатов, и для детальных записей: берётся понедельник текущей календарной недели (`getCurrentWeek()` в Edge Function). Это ключ для выборок на фронтенде.

## 4.1. Ограничения / scope данных

Вкладка "Задачи" отображает статистику только по личным задачам фотографа из проекта "Arbuz Контент. Задачи":

- **Фильтрация на уровне Asana API**: Edge Function запрашивает задачи через endpoint `/tasks` с параметрами `workspace=ARBUZ_WORKSPACE_GID`, `project=ARBUZ_CONTENT_PROJECT_GID`, `assignee=me`. Это гарантирует, что из Asana приходят только задачи текущего пользователя из нужного проекта.

- **Защитная фильтрация перед записью**: перед записью в `asana_tasks` Edge Function дополнительно проверяет, что у задачи есть `assignee` и что `task.assignee.gid === TIMETRACK_ASSIGNEE_GID` (если переменная окружения установлена). Задачи других исполнителей или без исполнителя не попадают в таблицу.

- **Влияние на KPI и таблицу подробностей**: все расчёты в `asana_stats` и отображение в Tasks Tab выполняются только по задачам, прошедшим фильтрацию и записанным в `asana_tasks`. Это означает:
  - Задачи других исполнителей не показываются в статистике, даже если они есть в Asana.
  - Задачи вне проекта "Arbuz Контент. Задачи" не попадают в статистику, даже если они есть в Asana.
  - Все суммы и счётчики KPI относятся только к личным задачам фотографа (assignee = owner).

## 5. Расчёт показателей на экране

Данные берутся из `asana_stats` за текущую неделю (см. `getAsanaStats()` в `app.js`, строки ~1813–1874).

- **«Отснято на неделе» (`#completedCount`)**  
  Источник: `asana_stats.completed_count` (равно `done_qty`).  
  Это KPI "Сделано", показывающее сумму `done_fact_this_week + carry_over_from_prev`.  
  - `done_fact_this_week` строится по фактическим датам (`week_processed`, далее `week_shot`, далее `week_completed`).
  - `carry_over_from_prev` — переработка с прошлой недели, сохраняется при записи в `asana_stats`.
  - Если `done_fact_this_week` превышает план текущей недели, излишек попадает в `overtime_qty`, который на следующей неделе станет `carry_over_from_prev`.

- **«Предстоит отснять» (`#pendingCount`)**  
  Источник: `asana_stats.pending_count` (равно `to_shoot_qty`).  
  Это объём задач, у которых дедлайн (`due_on`) попадает в текущую неделю, `Q > 0`, и задача ещё не завершена (`completed != true`).  
  Неделя всегда определяется по `due_on` (понедельник–воскресенье).  
  Этот показатель показывает «что ещё не сделано, но должно быть выполнено в эту неделю по сроку».

- **«Запланировано» (`#totalPlan`)**  
  Источник: `asana_stats.total_plan` (равно `week_load`).  
  `week_load = done_fact_this_week + to_shoot_qty`.  
  Таким образом карточка «Запланировано» показывает совокупную нагрузку недели: фактически сделанное в этой неделе + объём, ещё не выполненный, но со сроком в этой неделе.

- **«До выполнения плана» (`#remainingCount`)**  
  Источник: `asana_stats.remaining_to_plan`.  
  Формула: `remaining_to_plan = max(0, plan - done_fact_this_week)`, где `plan` — динамический план (80–100) для текущей недели.  
  Визуальное оформление карточки (`#cardRemaining`) зависит от знака `remaining_to_plan`: отрицательные значения означают перевыполнение и подсвечиваются зелёным.

- **Состояние карточки** (`#cardRemaining` + `#remainingText`)  
  Параметры стилей и подпись меняются в `updateTasksCards()` в зависимости от знака `remaining_to_plan`.

## 6. Детальный список («Показать подробности»)
- Фронтенд вызывает `getAsanaTasksDetailsByWeekStart(week_start_date)` (см. `app.js`):  
  ```js
  supabaseClient
    .from('asana_tasks')
    .select('task_name, q, product_source, shot_at, processed_at, due_on, completed, project_gid, assignee_gid')
    .or(`week_shot.eq.${weekStartStr},week_processed.eq.${weekStartStr}`)
    .order('processed_at', { ascending: false })
    .order('shot_at', { ascending: false })
    .order('due_on', { ascending: true })
  ```
- Полученные записи кешируются в `cachedTasksDetails` и отображаются `renderTasksDetailsFromCache()` как таблица. Используются поля:
  - `task_name` — название задачи; под ним мелким текстом показываются `project_gid` и `assignee_gid`
  - `q` — количество товаров из поля Q; если `q <= 0`, колонка подсвечивается красным и добавляется значок `⚠`
  - `shot_at` — дата съёмки (поле "когда сфоткал")
  - `processed_at` — дата обработки (поле "когда обработал" или `completed_at`, если поле пустое)
  - `product_source` — источник товара ("Принесли" или "Со склада")
  - `completed` — статус; в таблице отображается "Сделано" или "Не сделано" с соответствующим цветом
  - `due_on` — плановая дата (срок выполнения)
  - `project_gid` — сопоставляется с человеком читаемым именем через объект `ASANA_PROJECT_LABELS` и выводится отдельной колонкой
- Задачи выбираются по фактическим датам съёмки (`week_shot`) или обработки (`week_processed`), а не по плановой дате (`due_on`).
- Если данных ещё нет, UI показывает плейсхолдер «Нет данных для отображения».
- В таблицу встроены два фронтенд-фильтра:
  - Чекбокс «Показать только ошибки Q» — оставляет строки, где `q == null` или `q <= 0`
  - Селект «Проект» — формируется из реальных `project_gid` недели; значения отображаются как `ASANA_PROJECT_LABELS[gid] || gid`
- Фильтрация выполняется **на фронтенде** (Supabase возвращает полный набор задач недели). Состояние фильтров логируется: `[[TasksTab Details Debug]] Фильтрация деталей { totalRows, filteredRows, filterState }`.
- Подсветка Q-ошибок синхронизирована с KPI `q_errors_count`: проблемные строки выделяются светло-красным фоном, колонка Q — красным жирным шрифтом с `⚠`.

## 7. Файлы фронтенда и ключевые участки
- `index.html`
  - Навигация `<a href="#/tasks" id="tabTasks">`.
  - Media query-стили для `#tasksGrid` на мобильных.
- `app.js`
  - `route()` (строки ~2827–2862) — маршрутизация и подсветка табов.
  - `renderTasks()` (строки ~1933–2208) — построение UI, инициализация хендлеров `#refreshStats` и `#showDetails`, фоновая загрузка деталей.
  - `updateTasksCards()` — без перерендера DOM обновляет цифры и визуальные стили карточек.
  - `getAsanaStats()` (строки ~1813–1874) — читает `asana_stats` с фильтром по `week_start_date`.
  - `getAsanaTasksDetailsByWeekStart()` и `renderTasksDetailsFromCache()` — полный цикл загрузки/рендера таблицы задач недели.
  - Кеширование (`cachedTasksStats`, `cachedTasksDetails`, `tasksDetailsExpanded`) предотвращает мерцание UI при повторном входе во вкладку.
- `ASANA_INTEGRATION.md` — эталонное описание бэкенд-логики, полезно при отладке Edge Functions или перегрузке cron/webhook-цепочек.

## 8. Серверные обработчики / API
- **Edge Function `fetch-asana-stats`**  
  - Файл: `supabase/functions/fetch-asana-stats/index.ts`.  
  - Роли: обращается в Asana API, считает агрегаты, upsert'ит `asana_stats` и `asana_tasks`, возвращает свежие данные фронту.  
  - Входы: HTTP POST без payload (используются секреты Supabase).  
  - Выходы: `{ success, data }`, где `data` — полный набор колонок таблицы `asana_stats`.

- **Edge Function `handle-asana-webhook`**  
  - Файл: `supabase/functions/handle-asana-webhook/index.ts`.  
  - Роли: принимает события `added/changed` по задачам проекта и вызывает `fetch-asana-stats`.  
  - Таким образом Asana пушит обновления без участия пользователя.

- **SQL функция `refresh_asana_stats()` + cron `refresh-asana-stats-frequent`**  
  - Файл: инструкции в `ASANA_INTEGRATION.md` §4.2–4.3.  
  - Роли: fallback-план — каждые 5 минут вызывают HTTP Edge Function (через `http()` в PostgreSQL), чтобы синхронизация с Asana шла даже без webhook.

- **Cron `clear-asana-stats-weekly` + скрипт `clean_asana_tasks.sql`**  
  - Роли: регулярная очистка старых недель, чтобы таблицы не росли бесконечно и UI не тянул устаревшие данные.

## 9. Сущности Supabase и критичные колонки

| Сущность | Файл/определение | Назначение | Ключевые колонки |
| --- | --- | --- | --- |
| `asana_stats` | SQL в `ASANA_INTEGRATION.md` §2.1, миграция: `migrate_asana_stats_schema.sql` | Хранит один агрегированный срез на неделю (сырые агрегаты по неделям) | `week_start_date` (уникальный ключ), `week_end_date`, **`week_load`** (сумма Q задач, сфотографированных на этой неделе по `week_shot`), **`plan`** (динамический план 80–100), **`done_qty`** (сумма Q задач, обработанных на этой неделе по `week_processed`), **`to_shoot_qty`** (сумма Q задач недели по съёмке, которые ещё не доведены до состояния "Сделано"), **`on_hand_qty`** (сумма Q задач недели, где `product_source = 'PRINESLI'` и обработка ещё не завершена), **`warehouse_qty`** (сумма Q задач недели, где `product_source = 'WAREHOUSE'` и работа не начата), **`shot_not_processed_qty`** (сумма Q задач недели, где `shot_at` есть, а `processed_at` ещё нет), **`q_errors_count`** (количество задач недели с проблемами по Q), `remaining_to_plan` (план - done_qty). Legacy: `completed_count`, `pending_count`, `total_plan` |
| `asana_tasks` | `create_asana_tasks_table.sql`, миграция: `migrate_asana_tasks_schema.sql` | Детализация всех задач недели (сырые данные задач из Asana) | `asana_task_gid` (уникальный ключ связи с Asana), `task_name`, **`q`** (количество товаров из поля Q, основной источник), `quantity` (legacy, старое поле "Кол-во товаров"), `completed`, `completed_at`, `due_on` (плановая дата, определяет неделю для KPI to_shoot/on_hand/warehouse), `assignee_gid`, `week_start_date` (понедельник недели по `due_on`, ключ для плановых KPI и UI), **`product_source`** (значение поля "Товар": "PRINESLI" или "WAREHOUSE"), **`shot_at`** (дата из поля "когда сфоткал"), **`processed_at`** (дата из поля "когда обработал" или `completed_at`, если поле пустое), **`week_shot`** (понедельник недели по `shot_at`, используется для фактических KPI), **`week_processed`** (понедельник недели по `processed_at`, используется для фактических KPI) |
| `refresh_asana_stats()` | SQL функция в `ASANA_INTEGRATION.md` §4.2 | Серверная функция запуска Edge Function из PostgreSQL | параметров нет; важно наличие `http()` расширения и `service_role_key` в `app.settings.service_role_key` |
| `refresh-asana-stats-frequent` | `cron.schedule` в той же секции | Планировщик `pg_cron`, который дергает `refresh_asana_stats()` каждые 5 минут | cron id `refresh-asana-stats-frequent` |
| `clear-asana-stats-weekly` | `cron.schedule` в §4.2 | Еженедельная очистка старых записей `asana_stats` | SQL: `DELETE FROM asana_stats WHERE week_start_date < CURRENT_DATE - INTERVAL '7 days'` |
| `clean_asana_tasks.sql` | корень репозитория | Утилитарный скрипт для ручной очистки `asana_tasks` (например, если структура изменилась) | важные условные блоки: удаление по `week_start_date`, полная очистка, диагностика `MIN/MAX week_start_date` |

**Роль таблиц:**
- `asana_tasks` — хранит сырые данные задач из Asana (название, Q, даты, статусы, кастомные поля, недели съёмки/обработки и плановые недели). Поля `week_shot`/`week_processed` используются для определения фактической недели, а `week_start_date` (по `due_on`) — для плановой недели. Это позволяет одному набору данных обслуживать как фактические, так и плановые KPI.
- `asana_stats` — хранит агрегированные показатели по неделям (динамический план, KPI "Сделано", предстоит отснять, объёмы по источникам товара, ошибки, переработку). Фактические поля (`done_fact_this_week`, `done_qty`, `overtime_qty`) строятся на базе недель `week_shot/processed`, а плановые (`to_shoot_qty`, `on_hand_qty`, `warehouse_qty`) — по `week_start_date`. Новые поля (`week_load`, `plan`, `done_qty`, `to_shoot_qty`, `on_hand_qty`, `warehouse_qty`, `shot_not_processed_qty`, `q_errors_count`, `overtime_qty`, `carry_over_from_prev`) заменяют legacy поля (`completed_count`, `pending_count`, `total_plan`), которые сохраняются для обратной совместимости.

**Миграция схемы:**
- Для обновления существующих таблиц используйте скрипты из папки `supabase/sql/`:
  - `patch-asana-tasks-schema.sql` — добавляет новые поля в `asana_tasks`
  - `patch-asana-stats-schema.sql` — добавляет новые поля в `asana_stats`
- Эти скрипты идемпотентны: их можно запускать несколько раз без ошибок.
- **Применение:** Откройте Supabase Dashboard → SQL Editor, скопируйте содержимое скрипта и выполните его.

**Синхронизация схемы Supabase:**
См. раздел "Синхронизация схемы Supabase" ниже для подробных инструкций.

Эти сущности работают совместно: `fetch-asana-stats` является единственной точкой записи, `asana_stats` и `asana_tasks` — источники правды для фронтенда, cron/webhook-функции обеспечивают своевременное обновление, а утилитарные SQL-скрипты поддерживают чистоту данных.

---

Используйте этот документ как карту: он показывает куда идти (пути к файлам) и какую логику нужно учитывать, если вы меняете API Asana, целевые метрики или внешний вид вкладки «Задачи».

## 10. Обработка ошибок и нестандартные ситуации
- **Asana API недоступен / отвечает ошибкой**  
  Edge Function `fetch-asana-stats` оборачивает обращение в `try/catch` и возвращает `{ success: false, error: message }`. На фронтенде обработчик кнопки `#refreshStats` ловит исключение, показывает `alert('Ошибка обновления данных: ...')`, возвращает кнопку в активное состояние, но повторных попыток и бэк-оффа нет.
- **Supabase недоступен**  
  - На фронтенде `getAsanaStats()` и `getAsanaTasksDetailsByWeekStart()` проверяют `supabaseClient`; при его отсутствии либо возвращают кеш `cachedTasksStats`, либо дефолтные нули (80 план).  
  - При ошибке чтения Supabase (`error.code !== 'PGRST116'`) логируется `console.error`, и снова используется кеш или нули. Пользователь видит устаревшие данные без явного уведомления.
  - При записи в Edge Function ошибки Supabase приводят к HTTP 500 и всплывают в UI как `alert`.
- **UI реакция**  
  - При успешном обновлении показывается `alert('Данные успешно обновлены!')`.  
  - При ошибке — `alert('Ошибка обновления данных: ...')`, кнопка включается обратно.  
  - Секция «Подробности» при сетевых сбоях показывает текст `Ошибка загрузки данных` или `Нет данных для отображения`, но автоматических повторных запросов нет.

## 11. Известные ограничения текущей реализации
- **Жёсткая привязка к одному проекту и исполнителю**: ID проекта (`1210258013776969`) и пользователя (`1210252517070407`) захардкожены в Edge Function; переключение на другой проект потребует изменения кода и повторного деплоя.
- **Зависимость от конкретных кастомных полей Asana**: 
  - Поле Q (количество товаров) должно существовать в Asana и быть заполнено для учёта задачи в расчётах.
  - Поле "Товар" должно иметь значения "Принесли" или "Взять самому со склада".
  - Поля "когда сфоткал" и "когда обработал" должны быть кастомными полями с типом дата.
  - Отсутствие любого из этих полей или переименование в Asana приведёт к игнорированию задач или некорректным расчётам.
- **Старое поле "Кол-во товаров" (GID `1210420107320602`)**: больше не используется в расчётах, хранится только как legacy. Если в коде остались ссылки на это поле, они должны быть заменены на поле Q.
- **Динамический план 80–100**: план вычисляется автоматически на основе недельной нагрузки по факту съёмки (`week_load`), но диапазон 80–100 захардкожен в Edge Function. Изменение диапазона требует правки кода и редеплоя.
- **Критерий "Сделано" требует всех условий**: задача должна иметь `Q > 0`, `completed = true`, и `processed_at` заполнено. Если хотя бы одно условие не выполнено, задача не считается "Сделано".
- **Неделя определяется по фактическим датам**: все KPI строятся по фактическим датам съёмки (`week_shot`) и обработки (`week_processed`), а не по плановой дате (`due_on`). Поле `due_on` сохраняется только как справочное.
- **Один пользователь / нет фильтра по статусам**: логика считает все задачи указанного исполнителя вне зависимости от тегов/секций; нет поддержки нескольких аккаунтов или команд.
- **Нет локального кеша на случай офлайна**: при отсутствии Supabase данные либо старые из памяти, либо нули — новый рендер переотрисует пустые карточки.
- **Ограниченный набор данных в деталях**: `getAsanaTasksDetailsByWeekStart` может не выбирать все новые поля (`q`, `shot_at`, `processed_at`, `product_source`), если фронтенд не обновлён; требуется синхронизация с новой схемой.
- **Отсутствие пагинации/истории**: экран работает только с текущей неделей; нет переключения по датам или просмотра прошлых недель, хотя данные в таблицах могут сохраняться.

## 12. TODO и потенциальные улучшения
- **Гибкая конфигурация параметров Asana**  
  - Вынести `PROJECT_ID`, `USER_ID`, GID полей Q, "Товар", "когда сфоткал", "когда обработал", диапазон динамического плана (80–100) в Supabase таблицу настроек или переменные окружения, чтобы менять без редеплоя.
- **Миграция с legacy поля "Кол-во товаров"**  
  - Убедиться, что весь код использует поле Q вместо старого `1210420107320602`.  
  - Рассмотреть возможность удаления колонки `quantity` из `asana_tasks` после полной миграции.
- **Улучшение обработки ошибок/ретраев**  
  - Добавить повторные попытки и пользовательские статусы (toast/баннер вместо `alert`) при сбое Edge Function или Supabase.  
  - Логировать ошибки в Supabase (например, таблица logs) для пост-мортема.  
  - Обработать случаи, когда поле Q отсутствует или имеет некорректное значение (0, отрицательное, null).
- **Расширение модели данных для UI**  
  - Обновить `getAsanaTasksDetailsByWeekStart` для выборки новых полей (`q`, `shot_at`, `processed_at`, `product_source`).  
  - Показывать в детальном списке источник товара ("Принесли" / "Взять со склада") и даты съёмки/обработки.  
  - Добавить фильтры по статусу/типу задач, источнику товара или переключатель недели на фронтенде.
- **Улучшение логики переработки между неделями**  
  - Добавить визуализацию переработки (какая часть Q зачтена в прошлую неделю, какая в текущую).  
  - Рассмотреть возможность настройки правил распределения переработки через конфигурацию.
- **Оптимизация фронтенда**  
  - Избавиться от inline-стилей/`innerHTML` при рендере карточек, заменить на компонентный подход для лучшей поддержки.  
  - Добавить индикатор последнего обновления и время синхронизации (поле уже доступно как `updated_at`).  
  - Показывать статус задачи в детальном списке (достигнуто "Сделано" или нет, какие условия не выполнены).
- **Валидация данных**  
  - Добавить проверку корректности значений полей Q, "когда сфоткал", "когда обработал" (например, "когда обработал" не может быть раньше "когда сфоткал").  
  - Валидировать значения поля "Товар" (только "Принесли" или "Взять самому со склада").
- **Наблюдаемость и тесты**  
  - Писать метрики/логи при вызове Edge Function (успех/ошибка, длительность, количество обработанных задач, распределение по статусам).  
  - Автоматические тесты для `fetch-asana-stats` с моками Asana API и Supabase, включая тесты для логики переработки между неделями и динамического плана.  
  - Тесты для критерия "Сделано" (проверка всех условий).

Эти пункты можно использовать как базовый бэклог для повышения устойчивости вкладки «Задачи» и подготовки к будущим изменениям.

## 13. Синхронизация схемы Supabase

### Ожидаемая схема таблиц

Для корректной работы вкладки "Задачи" в Supabase должны существовать следующие таблицы с указанными полями:

#### Таблица `asana_tasks` (сырые данные задач)

**Обязательные поля:**
- `asana_task_gid` (TEXT, UNIQUE) — GID задачи из Asana
- `task_name` (TEXT) — название задачи
- `completed` (BOOLEAN) — завершена ли задача
- `completed_at` (TIMESTAMPTZ) — дата завершения
- `due_on` (DATE) — дедлайн задачи
- `week_start_date` (DATE, NOT NULL) — понедельник недели по due_on

**Новые поля (требуются для новой бизнес-логики):**
- `q` (INTEGER) — количество товаров из поля Q (основной источник)
- `product_source` (TEXT) — источник товара: 'PRINESLI' или 'WAREHOUSE'
- `shot_at` (DATE) — дата из поля "когда сфоткал"
- `processed_at` (DATE) — дата из поля "когда обработал" или completed_at
- `week_shot` (DATE) — понедельник недели по shot_at
- `week_processed` (DATE) — понедельник недели по processed_at

**Legacy поля (сохраняются для обратной совместимости):**
- `quantity` (INTEGER) — старое поле "Кол-во товаров"

#### Таблица `asana_stats` (агрегированная статистика по неделям)

**Обязательные поля:**
- `week_start_date` (DATE, UNIQUE) — понедельник недели (уникальный ключ)
- `week_end_date` (DATE) — воскресенье недели
- `remaining_to_plan` (INTEGER) — остаток до выполнения плана

**Новые поля (требуются для новой бизнес-логики):**
- `week_load` (INTEGER) — суммарный Q задач недели
- `plan` (INTEGER) — динамический план недели (80–100)
- `done_qty` (INTEGER) — KPI "Сделано" с учётом переработки
- `to_shoot_qty` (INTEGER) — объём "Предстоит отснять"
- `on_hand_qty` (INTEGER) — объём товара "Принесли" и/или сфоткан, но не обработан
- `warehouse_qty` (INTEGER) — объём задач "Взять со склада", работа не начата
- `shot_not_processed_qty` (INTEGER) — Q задач с shot_at, но без processed_at
- `q_errors_count` (INTEGER) — количество проблемных задач недели

**Legacy поля (сохраняются для обратной совместимости):**
- `completed_count` (INTEGER) — legacy: отснято на неделе
- `pending_count` (INTEGER) — legacy: предстоит отснять
- `total_plan` (INTEGER) — legacy: запланировано товаров

### Применение патчей схемы

Для синхронизации реальной схемы Supabase с ожидаемой схемой используйте SQL-скрипты из папки `supabase/sql/`:

**Способ 1: Через Supabase Dashboard (рекомендуется)**

1. Откройте [Supabase Dashboard](https://supabase.com/dashboard)
2. Выберите ваш проект
3. Перейдите в **SQL Editor**
4. Откройте файл `supabase/sql/patch-asana-tasks-schema.sql`
5. Скопируйте содержимое файла
6. Вставьте в SQL Editor и нажмите **Run**
7. Повторите для файла `supabase/sql/patch-asana-stats-schema.sql`

**Способ 2: Через Supabase CLI (если установлен)**

```bash
# Применить патч для asana_tasks
supabase db execute -f supabase/sql/patch-asana-tasks-schema.sql

# Применить патч для asana_stats
supabase db execute -f supabase/sql/patch-asana-stats-schema.sql
```

**Важно:**
- Скрипты идемпотентны: их можно запускать несколько раз без ошибок
- Скрипты **НЕ удаляют** и **НЕ переименовывают** существующие поля
- Скрипты **НЕ затрагивают** таблицы, связанные с учётом прихода/ухода с работы

### Проверка после применения

После применения патчей проверьте структуру таблиц:

```sql
-- Проверка структуры asana_tasks
SELECT column_name, data_type, is_nullable
FROM information_schema.columns 
WHERE table_name = 'asana_tasks' 
ORDER BY ordinal_position;

-- Проверка структуры asana_stats
SELECT column_name, data_type, is_nullable, column_default
FROM information_schema.columns 
WHERE table_name = 'asana_stats' 
ORDER BY ordinal_position;
```

Убедитесь, что все новые поля присутствуют в результатах запросов.

### Файлы SQL-скриптов

- `supabase/sql/patch-asana-tasks-schema.sql` — патч для таблицы `asana_tasks`
- `supabase/sql/patch-asana-stats-schema.sql` — патч для таблицы `asana_stats`
- `supabase/sql/apply-asana-schema-patches.sql` — объединённый скрипт (для CLI)

**Альтернативные файлы (в корне проекта):**
- `migrate_asana_tasks_schema.sql` — альтернативная версия патча для `asana_tasks`
- `migrate_asana_stats_schema.sql` — альтернативная версия патча для `asana_stats`

## 14. Изменения логики

**Версия v3 – неделя по due_on + фактическим датам, с переработкой (2025 Q4):**

- Плановые показатели (`to_shoot_qty`, `on_hand_qty`, `warehouse_qty`) рассчитываются по неделям `due_on`/`week_start_date`.
- Фактические показатели (`done_fact_this_week`, `done_qty`, `shot_not_processed_qty`) строятся по фактическим датам (`shot_at`, `processed_at`, `completed_at`).
- `week_load = done_fact_this_week + to_shoot_qty`, план сравнивается именно с `done_fact_this_week`.
- Введены `overtime_qty` и `carry_over_from_prev`, чтобы отражать переработку между неделями.
- Поле `due_on` теперь официально используется как источник правды для планирования, а фактические даты отвечают за зачёт выполненной работы.

**v3-tasks-kpi – детализация UI (2025 Q4):**
- Таблица «Показать подробности» подсвечивает Q-ошибки (красный фон строки, красный `⚠` в колонке Q) и показывает дополнительные колонки «Статус», «Проект».
- Появились фронтенд-фильтры: чекбокс «Показать только ошибки Q» и селект по проекту (значения берутся из `ASANA_PROJECT_LABELS`).
- Supabase отдаёт полный набор задач недели, а фильтрация происходит в браузере; состояние фильтров логируется `[[TasksTab Details Debug]]`.
