# Спецификация новой логики расчёта недельных KPI для вкладки "Задачи" TimeTrack

## Текущие ограничения

- **Динамический план 80–100** создаёт путаницу: план меняется в зависимости от нагрузки, что делает его непредсказуемым и не даёт чёткого ориентира для планирования работы.
- **Потеря контекста по долгам прошлых недель**: текущая модель не сохраняет информацию о том, сколько товаров не было сделано в прошлые недели, что приводит к потере важного контекста для пользователя.
- **Непонятное поведение `carry_over_from_prev`**: переработка с прошлой недели просто добавляется к факту текущей недели, что раздувает показатель "Сделано" и не даёт понимания, сколько реально сделано в текущей неделе, а сколько — это доработка прошлых недель.
- **Некорректный учёт товаров, обработанных с задержкой**: если товар был сфотографирован в прошлой неделе, а обработан в текущей, весь объём засчитывается в текущую неделю, что не отражает реальную картину работы и не учитывает долги прошлых недель.
- **Отсутствие прозрачности в распределении работы**: пользователь не видит, сколько товаров из текущей недели ушло на закрытие долгов прошлых недель, а сколько — это реальный факт текущей недели.

---

## Цели новой модели

- **Статичный план 80 товаров в неделю**: план всегда равен 80, независимо от нагрузки. Это даёт чёткий и предсказуемый ориентир для планирования и оценки работы.
- **Считать всё в ТОВАРАХ (Q), а не в количестве задач**: все KPI рассчитываются на основе поля `q` (количество товаров), что даёт более точную картину объёма работы.
- **Корректно учитывать товары, которые были сфотканы в прошлые недели, а обработаны в текущей**: товары, обработанные с задержкой, должны распределяться между неделями от недели съёмки до недели обработки, закрывая долги прошлых недель в первую очередь.
- **Не терять долги прошлых недель и не раздувать искусственно факт текущей недели**: долги прошлых недель должны сохраняться и учитываться при расчёте показателей, а факт текущей недели должен отражать только реально выполненную работу в эту неделю.
- **Иметь понятные показатели для UI**: пользователь должен видеть:
  - сколько товаров зачтено в текущую неделю после перераспределения (`done_fact_current_week`);
  - сколько товаров этой недели ушло на закрытие долгов прошлых недель (`done_from_past_weeks`);
  - сколько ещё не добито до плана 80 по текущей неделе (`debt_current_week`);
  - агрегированную информацию о долгах прошлых недель (`debts_by_week` или `debt_total_before`).

---

## Новые определения и сущности

### `plan_week = 80` (статичный план для каждой недели)

**Определение:** План для каждой недели всегда равен 80 товарам, независимо от фактической нагрузки или объёма работы. Это константа, которая не меняется в зависимости от `week_load` или других факторов.

**Использование:** Используется как базовая единица для расчёта долгов и перевыполнения каждой недели.

**Важно:** В новой модели мы больше НЕ используем динамический план 80–100. План всегда 80.

---

### `done_week` (факт выполненных товаров, зачтённых в эту неделю)

**Определение:** Количество товаров (сумма `q`), которые были зачтены в конкретную неделю после применения алгоритма перераспределения обработанных товаров.

**Особенности:**
- После перераспределения товаров, обработанных с задержкой, `done_week` может включать:
  - товары, которые были сфотканы и обработаны в эту неделю;
  - часть товаров, которые были сфотканы в прошлые недели, но обработаны в эту (если после закрытия долгов прошлых недель остался остаток);
  - товары, которые были обработаны в эту неделю, но не имеют `shot_at` (используется `completed_at`).

**Использование:** Основной показатель для оценки выполнения плана недели.

---

### `debt_week = max(0, plan_week - done_week)` (долг недели до плана 80)

**Определение:** Количество товаров, которое не было выполнено в конкретную неделю до достижения плана 80.

**Формула:** `debt_week = max(0, 80 - done_week)`

**Особенности:**
- Если `done_week >= 80`, то `debt_week = 0` (план выполнен или перевыполнен).
- Если `done_week < 80`, то `debt_week = 80 - done_week` (есть долг до плана).
- Долг сохраняется в `asana_stats` для каждой недели и используется при перераспределении товаров из будущих недель.

**Использование:** Показывает, сколько товаров не хватает до выполнения плана 80 в конкретной неделе.

---

### `over_week = max(0, done_week - plan_week)` (перевыполнение недели, опционально)

**Определение:** Количество товаров, на которое была перевыполнена неделя сверх плана 80.

**Формула:** `over_week = max(0, done_week - 80)`

**Особенности:**
- Если `done_week <= 80`, то `over_week = 0` (нет перевыполнения).
- Если `done_week > 80`, то `over_week = done_week - 80` (есть перевыполнение).
- Перевыполнение может быть использовано для закрытия долгов прошлых недель (если они есть) или для учёта в статистике.

**Использование:** Показывает, на сколько товаров была перевыполнена неделя (для информационных целей или для закрытия долгов прошлых недель).

**Примечание:** Это поле опционально и может быть добавлено позже, если потребуется более детальная аналитика.

---

### "Товар из прошлой недели" (товар, обработанный с задержкой)

**Определение:** Товар (часть `task.q`), который был сфотографирован в прошлой неделе (или раньше), а обработан в текущей неделе (или позже).

**Критерии:**
- `task.shot_at` относится к неделе `< currentWeek` (неделя съёмки раньше текущей недели);
- `task.processed_at` относится к неделе `>= currentWeek` (неделя обработки в текущей или позже);
- `task.q > 0` (товар имеет количество).

**Особенности:**
- Такой товар должен быть распределён между неделями от `week_shot` до `week_processed` включительно.
- Приоритет распределения: сначала закрываются долги прошлых недель, затем остаток идёт в факт недели обработки.

**Пример:**
- Товар с `q = 30` был сфотографирован в неделю `2025-11-17` (понедельник), обработан в неделю `2025-11-24` (понедельник следующей недели).
- Если в неделе `2025-11-17` был долг `debt_week = 20`, а в неделе `2025-11-24` долга нет, то:
  - 20 товаров идут на закрытие долга недели `2025-11-17`;
  - 10 товаров идут в факт недели `2025-11-24`.

---

## Алгоритм распределения обработанных товаров по неделям

### Общая логика

Когда товар был сфотографирован в прошлой неделе (или раньше), а обработан в текущей неделе (или позже), его количество `N = task.q` должно быть распределено между неделями от `week_shot` до `week_processed` включительно.

**Цель распределения:** Сначала закрыть долги прошлых недель, затем остаток засчитать в факт недели обработки.

---

### Псевдокод алгоритма

```
ФУНКЦИЯ distributeProcessedGoods(task, currentWeek):
  // task.q - количество товаров в задаче
  // task.week_shot - неделя съёмки (понедельник)
  // task.week_processed - неделя обработки (понедельник)
  // currentWeek - текущая неделя (понедельник)
  
  N = task.q  // Остаток товаров для распределения
  weekStart = task.week_shot  // Начинаем с недели съёмки
  weekEnd = task.week_processed  // Заканчиваем неделей обработки
  
  // Проходим по неделям от week_shot до week_processed включительно
  ДЛЯ каждой недели week ОТ weekStart ДО weekEnd:
    // Получаем долг недели (если запись существует в asana_stats)
    debt_week = получить_debt_week(week)  // max(0, 80 - done_week)
    
    // Если это не текущая неделя, пытаемся закрыть долг
    ЕСЛИ week < currentWeek И debt_week > 0:
      allocate = min(N, debt_week)  // Сколько товаров идёт на закрытие долга
      N = N - allocate  // Уменьшаем остаток
      обновить_done_week(week, allocate)  // Увеличиваем done_week недели на allocate
      обновить_debt_week(week)  // Пересчитываем долг недели (должен уменьшиться)
    
    // Если это текущая неделя, остаток идёт в факт текущей недели
    ИНАЧЕ ЕСЛИ week == currentWeek:
      обновить_done_week(week, N)  // Весь остаток идёт в факт текущей недели
      N = 0  // Остаток исчерпан
    
    // Если остаток исчерпан, выходим из цикла
    ЕСЛИ N <= 0:
      ПРЕРВАТЬ цикл
  
  КОНЕЦ ФУНКЦИИ
```

---

### Пошаговое описание алгоритма

1. **Инициализация:**
   - Берём задачу с `task.q = N` товаров.
   - Определяем диапазон недель: от `week_shot` до `week_processed` включительно.
   - Инициализируем остаток `N` для распределения.

2. **Проход по неделям от недели съёмки до недели обработки:**
   - Для каждой недели `week` в диапазоне `[week_shot, week_processed]`:
     - Получаем текущий долг недели: `debt_week = max(0, 80 - done_week)` (из `asana_stats` или вычисляем).
     - Если `week < currentWeek` (прошлая неделя) и `debt_week > 0` (есть долг):
       - Вычисляем, сколько товаров идёт на закрытие долга: `allocate = min(N, debt_week)`.
       - Уменьшаем остаток: `N = N - allocate`.
       - Увеличиваем `done_week` для недели `week` на `allocate`.
       - Пересчитываем `debt_week` для недели `week` (должен уменьшиться или стать 0).
     - Если `week == currentWeek` (текущая неделя):
       - Весь остаток `N` идёт в `done_week` текущей недели.
       - Остаток исчерпан: `N = 0`.
     - Если `N <= 0` (остаток исчерпан), прерываем цикл.

3. **Результат:**
   - Долги прошлых недель закрыты (если были и если хватило товаров).
   - Остаток товаров засчитан в факт недели обработки.

---

### Примеры работы алгоритма

#### Пример 1: Закрытие долга прошлой недели

**Исходные данные:**
- Неделя `2025-11-17`: `done_week = 60`, `debt_week = 20` (не хватает 20 товаров до плана 80).
- Неделя `2025-11-24` (текущая): `done_week = 0`, `debt_week = 80`.
- Задача: `q = 30`, `week_shot = 2025-11-17`, `week_processed = 2025-11-24`.

**Распределение:**
1. Неделя `2025-11-17`: `debt_week = 20`, `allocate = min(30, 20) = 20`.
   - `N = 30 - 20 = 10`.
   - `done_week(2025-11-17) = 60 + 20 = 80`.
   - `debt_week(2025-11-17) = max(0, 80 - 80) = 0` (долг закрыт).
2. Неделя `2025-11-24` (текущая): остаток `N = 10` идёт в факт текущей недели.
   - `done_week(2025-11-24) = 0 + 10 = 10`.
   - `debt_week(2025-11-24) = max(0, 80 - 10) = 70`.

**Результат:** Долг прошлой недели закрыт (20 товаров), остаток (10 товаров) засчитан в текущую неделю.

---

#### Пример 2: Недостаточно товаров для закрытия долга

**Исходные данные:**
- Неделя `2025-11-17`: `done_week = 60`, `debt_week = 20`.
- Неделя `2025-11-24` (текущая): `done_week = 0`, `debt_week = 80`.
- Задача: `q = 15`, `week_shot = 2025-11-17`, `week_processed = 2025-11-24`.

**Распределение:**
1. Неделя `2025-11-17`: `debt_week = 20`, `allocate = min(15, 20) = 15`.
   - `N = 15 - 15 = 0`.
   - `done_week(2025-11-17) = 60 + 15 = 75`.
   - `debt_week(2025-11-17) = max(0, 80 - 75) = 5` (долг частично закрыт, осталось 5 товаров).

**Результат:** Долг прошлой недели частично закрыт (15 из 20 товаров), остаток долга (5 товаров) сохраняется.

---

#### Пример 3: Товар обработан в ту же неделю, что и сфотографирован

**Исходные данные:**
- Неделя `2025-11-24` (текущая): `done_week = 50`, `debt_week = 30`.
- Задача: `q = 40`, `week_shot = 2025-11-24`, `week_processed = 2025-11-24`.

**Распределение:**
1. Неделя `2025-11-24` (текущая): весь остаток `N = 40` идёт в факт текущей недели.
   - `done_week(2025-11-24) = 50 + 40 = 90`.
   - `debt_week(2025-11-24) = max(0, 80 - 90) = 0` (план выполнен, есть перевыполнение 10 товаров).

**Результат:** Весь товар засчитан в текущую неделю, план выполнен.

---

### Важные замечания

1. **Статичный план 80:** Мы больше НЕ пытаемся динамически поднимать план до 100. План всегда равен 80 товарам в неделю, независимо от нагрузки.

2. **Устаревшие поля:** Старые поля `overtime_qty` и `carry_over_from_prev` в текущем виде становятся не нужны или будут перепридуманы позже. Это TODO для будущей реализации.

3. **Приоритет закрытия долгов:** При распределении товаров сначала закрываются долги прошлых недель (в хронологическом порядке от недели съёмки), затем остаток идёт в факт недели обработки.

4. **Учёт перевыполнения:** Если после закрытия долгов и зачёта в текущую неделю `done_week > 80`, это считается перевыполнением, но не влияет на план следующей недели (план всегда 80).

---

## Новые KPI для UI вкладки "Задачи"

### Основные показатели для отображения

#### `done_fact_current_week` (сколько товаров зачтено в текущую неделю после перераспределения)

**Определение:** Количество товаров, зачтённых в текущую неделю после применения алгоритма перераспределения обработанных товаров.

**Расчёт:** Сумма `done_week` для текущей недели после перераспределения всех обработанных товаров.

**Использование на UI:** Основное значение в карточке "Сделано" для текущей недели.

**Связь с операционными статусами:** Этот показатель учитывает все товары, которые были обработаны (`processed_at` заполнено) в текущую неделю, независимо от того, когда они были сфотографированы.

---

#### `done_from_past_weeks` (сколько товаров этой недели ушло на закрытие долгов прошлых недель)

**Определение:** Количество товаров из текущей недели, которое было использовано для закрытия долгов прошлых недель при перераспределении обработанных товаров.

**Расчёт:** Сумма `allocate` для всех задач, где `week_processed = currentWeek`, но часть товаров пошла на закрытие долгов недель `< currentWeek`.

**Использование на UI:** Дополнительная мета-информация в карточке "Сделано", показывающая, сколько товаров из текущей недели ушло на доработку прошлых недель.

**Пример отображения:**
```
Сделано: 90 товаров
  └─ Факт недели: 70
  └─ Доработано из прошлых недель: 20
```

---

#### `debt_current_week` (сколько ещё не добито до плана 80 по текущей неделе)

**Определение:** Количество товаров, которое не хватает до выполнения плана 80 в текущей неделе.

**Расчёт:** `debt_current_week = max(0, 80 - done_fact_current_week)`

**Использование на UI:** Основное значение в карточке "До выполнения плана" для текущей недели.

**Особенности:**
- Если `done_fact_current_week >= 80`, то `debt_current_week = 0` (план выполнен).
- Если `done_fact_current_week < 80`, то `debt_current_week = 80 - done_fact_current_week` (есть долг).

---

#### `debt_total_before` (агрегированный долг прошлых недель, опционально)

**Определение:** Суммарный долг всех прошлых недель до текущей (сколько товаров не было сделано в прошлых неделях).

**Расчёт:** `debt_total_before = сумма(debt_week) для всех недель < currentWeek, где debt_week > 0`

**Использование на UI:** Дополнительный показатель, показывающий общий объём долгов прошлых недель (может быть отображён в виде мета-информации или отдельной карточки).

**Примечание:** Это поле опционально и может быть добавлено позже, если потребуется более детальная аналитика.

---

#### `debts_by_week` (долги по неделям, опционально)

**Определение:** Детализация долгов по каждой прошлой неделе (массив объектов `{ week_start_date, debt_week }`).

**Расчёт:** Для каждой недели `< currentWeek` вычисляется `debt_week = max(0, 80 - done_week)`.

**Использование на UI:** Может быть отображено в виде таблицы или списка при нажатии на "Показать подробности", чтобы пользователь видел, в каких неделях были долги и сколько товаров не хватало до плана.

**Примечание:** Это поле опционально и может быть добавлено позже, если потребуется более детальная аналитика.

---

### Связь с операционными статусами

#### `on_hand_qty` (уже на руках)

**Определение:** Сумма `q` задач, где товар уже принесли фотографу, но работа ещё не начата (товар физически находится у фотографа).

**Расчёт:** Сумма `q` для задач, где:
- `due_on` попадает в диапазон текущей недели;
- `q > 0`;
- `completed != true`;
- `product_source = 'PRINESLI'`;
- `shot_at IS NULL` (товар ещё не сфотографирован).

**Связь с новым алгоритмом:** Этот показатель работает по фактическим данным (`shot_at`, `product_source`) и не зависит от алгоритма перераспределения. Он показывает операционный статус товаров на текущий момент.

---

#### `warehouse_qty` (нужно взять со склада)

**Определение:** Сумма `q` задач, где нужно взять товар самому со склада, работа ещё не начата.

**Расчёт:** Сумма `q` для задач, где:
- `due_on` попадает в диапазон текущей недели;
- `q > 0`;
- `completed != true`;
- `product_source = 'WAREHOUSE'`;
- `shot_at IS NULL`;
- `processed_at IS NULL`.

**Связь с новым алгоритмом:** Этот показатель работает по фактическим данным (`shot_at`, `processed_at`, `product_source`) и не зависит от алгоритма перераспределения. Он показывает операционный статус товаров на текущий момент.

---

#### `shot_not_processed_qty` (сфоткано, но не обработано)

**Определение:** Сумма `q` задач, где фотосъёмка начата (есть `shot_at`), но обработка ещё не завершена (нет `processed_at`).

**Расчёт:** Сумма `q` для задач, где:
- `q > 0`;
- `week_shot = currentWeek` (сфоткано на этой неделе);
- `completed != true`;
- `shot_at IS NOT NULL`;
- `processed_at IS NULL`.

**Связь с новым алгоритмом:** Этот показатель работает по фактическим данным (`shot_at`, `processed_at`) и не зависит от алгоритма перераспределения. Он показывает операционный статус товаров на текущий момент.

**Важно:** Когда такой товар будет обработан (`processed_at` заполнено), он попадёт в алгоритм перераспределения и будет засчитан в `done_fact_current_week` (или в долги прошлых недель, если `week_shot < currentWeek`).

---

### Итоговая структура данных для UI

```typescript
{
  // Основные KPI текущей недели
  done_fact_current_week: number,      // Зачтено в текущую неделю после перераспределения
  done_from_past_weeks: number,        // Сколько товаров этой недели ушло на закрытие долгов прошлых недель
  debt_current_week: number,          // Сколько ещё не добито до плана 80 по текущей неделе
  plan_week: number,                  // Всегда 80 (статичный план)
  
  // Опциональные показатели
  debt_total_before: number,          // Агрегированный долг прошлых недель (опционально)
  debts_by_week: Array<{               // Долги по неделям (опционально)
    week_start_date: string,
    debt_week: number
  }>,
  
  // Операционные статусы (работают по фактическим данным, не зависят от алгоритма перераспределения)
  on_hand_qty: number,                // Уже на руках
  warehouse_qty: number,               // Нужно взять со склада
  shot_not_processed_qty: number,    // Сфоткано, но не обработано
  to_shoot_qty: number,               // Предстоит отснять (по due_on)
  q_errors_count: number,              // Ошибки Q
  
  // Служебные поля
  week_start_date: string,            // Понедельник текущей недели
  week_end_date: string,              // Воскресенье текущей недели
  updated_at: string | null,
  version: string                     // Версия Edge Function
}
```

---

## План внедрения

1. **Изменение расчёта в Edge Function:**
   - Модифицировать функцию `computeWeekAggregates()` для реализации алгоритма перераспределения обработанных товаров по неделям.
   - Убрать или переделать функцию `computeDynamicPlan()` (план всегда 80, динамический расчёт не нужен).
   - Добавить логику получения долгов прошлых недель из `asana_stats` и их закрытия при перераспределении товаров.
   - Реализовать функцию `distributeProcessedGoods(task, currentWeek)` для распределения товаров между неделями.

2. **Обновление структуры `asana_stats`:**
   - Добавить поле `debt_week` (INTEGER) для хранения долга каждой недели до плана 80.
   - Добавить поле `done_week` (INTEGER) для хранения факта выполненных товаров, зачтённых в эту неделю после перераспределения.
   - Опционально: добавить поле `over_week` (INTEGER) для хранения перевыполнения недели.
   - Обновить SQL-миграцию для добавления новых полей (создать новый файл миграции или обновить существующий).

3. **Обновление фронтенда:**
   - Обновить функцию `getAsanaStats()` для работы с новыми полями (`done_fact_current_week`, `done_from_past_weeks`, `debt_current_week`).
   - Обновить функцию `updateTasksCards(stats)` для отображения новых показателей:
     - Карточка "Сделано": использовать `done_fact_current_week` как основное значение, показывать `done_from_past_weeks` как мета-информацию.
     - Карточка "До выполнения плана": использовать `debt_current_week` вместо `remaining_to_plan`.
     - Карточка "Запланировано": показывать статичный план 80 вместо динамического `plan`.
   - Обновить функцию `renderTasks()` для отображения новых карточек и мета-информации.

4. **Тестирование:**
   - Протестировать алгоритм перераспределения на различных сценариях (закрытие долгов, перевыполнение, товары из прошлых недель).
   - Проверить корректность расчёта `debt_week` для каждой недели.
   - Убедиться, что операционные статусы (`on_hand_qty`, `warehouse_qty`, `shot_not_processed_qty`) работают корректно и не зависят от алгоритма перераспределения.

5. **Документация:**
   - Обновить документацию `docs/tasks-backend-current.md` после внедрения новой логики.
   - Обновить документацию `docs/tasks-tab-architecture.md` с описанием новых KPI и алгоритма перераспределения.

---

## Примечания

1. **Совместимость с текущей реализацией:** При внедрении новой логики необходимо обеспечить обратную совместимость или миграцию данных для существующих записей в `asana_stats`.

2. **Производительность:** Алгоритм перераспределения может требовать множественных запросов к `asana_stats` для получения долгов прошлых недель. Необходимо оптимизировать запросы (например, загружать все нужные недели одним запросом).

3. **Обработка граничных случаев:** Необходимо обработать случаи, когда:
   - Товар был сфотографирован, но `processed_at` ещё не заполнено (не попадает в алгоритм перераспределения до момента обработки).
   - Товар был обработан, но `shot_at` не заполнено (используется `completed_at` как дата обработки).
   - Несколько задач с одинаковыми `week_shot` и `week_processed` (каждая обрабатывается независимо).

4. **Версионирование:** После внедрения новой логики необходимо обновить версию Edge Function (например, `v4-static-plan-redistribution`) и добавить поле `version` в ответ для отслеживания версии на фронтенде.

